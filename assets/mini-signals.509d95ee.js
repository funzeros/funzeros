class e{constructor(t,i=!1,r){this._fn=t,this._once=i,this._thisArg=r,this._next=this._prev=this._owner=null}detach(){return this._owner===null?!1:(this._owner.detach(this),!0)}}function a(n,t){return n._head?(n._tail._next=t,t._prev=n._tail,n._tail=t):(n._head=t,n._tail=t),t._owner=n,t}class h{constructor(){this._head=this._tail=void 0}handlers(t=!1){let i=this._head;if(t)return!!i;const r=[];for(;i;)r.push(i),i=i._next;return r}has(t){if(!(t instanceof e))throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");return t._owner===this}dispatch(){let t=this._head;if(!t)return!1;for(;t;)t._once&&this.detach(t),t._fn.apply(t._thisArg,arguments),t=t._next;return!0}add(t,i=null){if(typeof t!="function")throw new Error("MiniSignal#add(): First arg must be a Function.");return a(this,new e(t,!1,i))}once(t,i=null){if(typeof t!="function")throw new Error("MiniSignal#once(): First arg must be a Function.");return a(this,new e(t,!0,i))}detach(t){if(!(t instanceof e))throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");return t._owner!==this?this:(t._prev&&(t._prev._next=t._next),t._next&&(t._next._prev=t._prev),t===this._head?(this._head=t._next,t._next===null&&(this._tail=null)):t===this._tail&&(this._tail=t._prev,this._tail._next=null),t._owner=null,this)}detachAll(){let t=this._head;if(!t)return this;for(this._head=this._tail=null;t;)t._owner=null,t=t._next;return this}}export{h as M};
